---
title: 19.최초적합, 최적적합, 최악적합
date: 2019-02-25 08:30:26
tags:
categories:
- CS
- Operating System
thumbnail: /images/os.png
---
메모리 낭비를 줄이기 위한 기법
1.Dynamic Loading
2.Dynamic Linking
3.Swapping

### 연속 메모리 할당
최초의 컴퓨터는 프로세스가 하나만 올라갔다. 그이 후 O/S가 올라가게 되었다.
하나의 운영체제에 여러개의 프로세스가 도는것이 다중프로그래밍. 즉 멀티프로그래밍이라 한다.
부팅을 하면 메모리가 비어있다가 OS가 자리잡게된다. OS이외에 부분은 비어있는데 이를 <u>big single hole 또는 hole</u>이라고 한다.

`부팅 직후 메모리 상태`: O/S + big single hole
`프로세스 생성 & 종료 반복 ` : scattered holes(프로세스가 생성됐다가 없어지고 하다보면 곳곳에 hole 발생하게 된다.)

Hole 들이 불연속하게 흩어져 있기 때문에 프로세스 적재 불가한 경우가 생기는데 이를 <u>외부단편화(external fragmentation)</u>라 한다.

`First-fit (최초 적합)`  : 메모리를 뒤져서 가장 처음에 들어갈 수 있는곳에 들어가는것.
`Best-fit (최적 적합)` : 사이즈가 제일 비슷한놈에 들어가는것.
`Worst-fit (최악 적합)` : 크기가 제일 안맞는놈한테 넣는것.(물론 큰것중에)

#### 예제
Hole: 100 /500 / 600 / 300 / 200 KB
프로세스: 212 417 112 426 KB

`First-fit (최초 적합)`의 경우 : 212는 500에 들어간다. 417은 600에 들어감. 112는 300에 들어감. 426은 못들어감.

`Best-fit (최적 적합)` : 212는 300에 들어간다 . 417은 500 112는 200 .426은 500

`Worst-fit (최악 적합)` : 212는 600에. 417은 500에. 112는 300에. 426은 못들어간다.

속도면에서는 First-fit가 빠르다.
나머지는 다 봐야하기 때문에 느리다.

이용률의 경우 first-fit, best-fit이 높은 이용율이 보임.
외부 단편화로 인한 메모리 낭비가 전체의 1/3 수준 (사용 불가)

`이를 해결하기 위한 방법` : Compaction(hole들을 한곳으로 모으는것. 최적 알고리즘 없음, 고부담)
즉 OS가 지켜보다가 hole들을 한곳으로 모은다.(계산 부담)

`다른방법은 없을까?` 페이징

### 페이징
프로그램을 연속적으로 넣지 않고 일정한 단위로 잘라서 넣는다 이를 페이지라고 한다.(잘린것들을 말함).
메모리를 자른것을 프레임이라 함.

프로세스를 자른것을 페이지라 하고 메모리를 자른것을 프레임이라 한다.
페이지사이즈와 프레임사이즈 는 같으나 용어와 사용되는 위치가 다른것.

잘라서도 돌게하기 위해서는 CPU를 속여야한다. MMU 내의 Relocation Resgister을 여러개 둔다!
이러한 목적으로 사용되는 MMU를 페이지 테이블 (page table) 이라 한다.

이를 통해 외부단편화를 해결!


### 페이징에서의 주소변환
{% asset_img image1.png 페이징에서의 주소변환 %}
논리주소를 물리주소를 변환하는것을 주소변환이라한다.
CPU가 내는 주소가 m bit라 하자. 그럴 때 m-n은 페이지의 주소이고 n비트는 오프셋 또는 변위라고 한다.
즉 n은 페이지의 사이즈에 의존적이다. 페이지의 사이즈가 16일때 n은 4로 표현가능

메인메모리는 프레임 단위로 나뉘어져있다. 프레임의 크기는 페이지의 사이즈와 동일하다,
아까 말했듯 페이지 테이블(여러개의 mmu로 구성된것)은 프로세스가 페이지를 몇개쓰는가이 따라 달라진다.

p가 2라면 페이지 테이블의 두번째를 가르키는 것이고 d가 오프셋을 의미

만약 CPU가 50이라는 주소를 냈다하자. 그럼 110010(2) 이다. 이때 한 페이지가 16바이트라 가정했을 때 뒤의 네 수를 d로 보고 앞에 두개 11을 p로 본다. 즉 3번째 페이지에 저장되어있는 값(8이라 가정하자)에 맞는 프레임을 찾아가고 d를 활용하여 세부적인 값을 알아낸다. 이때는 10000010(2)가 된다,(앞에 네개는 8을 의미 뒤에 네개는 d를 그대로 가져다 쓴것)

정리하면 CPU가 내는 50번지는 10000010 즉 128번지 + d(2) 이므로 130번지를 찾아간다.

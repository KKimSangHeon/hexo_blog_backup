---
title: object
date: 2020-01-09 21:57:06
tags:
- OOP
categories:
- CS
- OOP
thumbnail: /images/object.png
---


### 오브젝트 9장
OCP - 추상화에 의존하여 컴파일 타임의존성은 유지하면서 런타임 의존성의 가능성을 확장하고 수정할 수 있는 구조.

객체 생성,사용자 분리 - 동일 클래스 안에서 객체 생성과 사용이라는 두가지 이질적인 목적을 가진 코드가 공존할 경우 부적절.
(Movie에게 금액할인정책을 적용할지, 비율할인 정책을 적용할지 알고 있는것은 그 시점에 Movie와 협력할 클라이언트이므로 클라이언트가 할인정책을 생성하고 Movie는 추상화된 메소드를 사용하여 구현)

FACTORY - 생성과 사용을 분리하기 위해 객체생성에 특화된 객체

표현적 분해 - 도메인에 존재하는 사물 또는 개념을 표현하는 객체들을 이용해 시스템 분해

PURE FABRICATION - 특정 책임을 할당하기 위해 Information expert를 찾아봤는데 없을 경우 도메인 모델에 속하지 않는 Factory를 활용. 보통 행위적 분해로 인해 생성되는것이 대부분

의존성주입 - 생성자 주입, setter주입, 메서드 주입(주입인가에 대한 논란이 있다)

SERVICE LOCATOR 패턴 - 저장소(Storage.AmountDiscountPolicy)를 통해 의존성 해결하는 패턴 (가장널리 쓰임 - 그렇지만 비추함)

의존성역전원칙 - 상위 모듈, 하위모듈 둘 다 추상화에 의존하라(과거 패러다임은 상위가 하위에 의존)

SEPARATED INTERFACE 패턴 - 추상화(인터페이스 등)를 별도의 패키지가 아닌 클라이언트가 속한 패키지에 포함시켜라


### 오브젝트 10장

상속을 위한 경고- 자식 클래스의 메소드 아넹서 super 참조를 이용해 부모클래스의 메소드를 호출할 경우 두 클래스는 강하게 결합된다. super호출을 제거 할 수읶는 방법을 찾아라

경고2 상속받은 부모 클래스의 메소드가 자식 클래스의 내부 구조에 대한 규칙을 깨뜨릴수있다
ex 스택 add(0,"data") 으로 맨앞에 넣는것...

경고3 자식 클래스가 부모 클래스의 메소드를 오버라이딩 할 경우 부모클래스가 자신의 메소드를 사용하는 방법에 클래스가 결합될 수 있다

경고4 클래스를 상속하면 결합도로 인해 자식 클래스와 부모 클래스의 구현을 영원히 변경하지 않거나, 자식 클래스와 부모 클래스를 동시에 변경하거나 둘 중 하나를 선택할 수 밖에 없다

취약한 기반 클래스문제- 자식클래스가 부모 클래스의 뱐경에 취약해지는 현상

상속문제 해결방법
1.차이를 메서드로 추출하라 -> 중복코드를 부모 클래스로 올려라(메소드 먼저 올리면 불필요한 인스턴스 변수를 남겨두기 쉽다) -> 다른부분은 시그니처만 올려라(protected로)

상속의 오용과 남용은 어플리케이션을 이해하고 확장하기 어렵게 만드므로 정말로 필요한 경우에만 사용하라


### 오브젝트 11장
재사용을 위한 방법 - 상속, 합성
상속관계 - Is-a - 화이트박스 재사용(부모클래스의 내부가 자식에 공개되기 때문)
합성관계 - Has-a - 블랙박스 재사용(객체의 내부는 공개되지 않고 인터페이스를 통해서만 재사용됨.)

상속은 결합도를 높이며 코드재사용을 위해서는 상속보다는 합성을 써라

상속은 부모클래스의 안에 구현된 코드에 의존하지만 합성은 객체의 퍼블릭 인터페이스를 의존하므로 결합도 낮아진다.

훅메서드 - 추상 메서드와 동일하게 자식 클래스에서 오버라이딩할 의도로 메서드를 추가했지만 편의를 위해 기본 구현을 제공하는 메서드.
ex , 추상클래스 내 afterCalculate 메소드를 단순히 retrun fee; 로 구현하고 다른 메서드가 afterCalculate를 호출할 경우 추상클래스를 상속한 클래스들은  afterCalculate메서드를 적절히 오버라이딩 하여 활용할 수 있다.

클래스폭발/조합의 폭발- 상속의 경우 부모의 구현에 강하게 결합되므로 하나의 기능을 추가하기 위해 필요이상으로 많은 수의 클래스를 추가해야하는 경우를 말함.


상속관계는 컴파일 타임에 결저되고 고정되기 때문에 코드를 실행하는 도중에는 변경불가함.
합성은 컴파일타임 관계를 런타임 관계로 변경함으로써 문제를 해결한다. 합성을 사용하면 구현이 아닌 퍼블릭 인터페이스에 대해서만 의존할 수 있기 때문에 런타임에 객체의 관계를 변경할 수 있따.

상속이 조합의 결과를 개별 클래스 안으로 밀어넣는 방법이라면 합성은 조합을 구성하는 요소들을 개별 클래스로 구현한 후 실행 시점에 인스턴스를 조립하는 방법을 사용하는것이다.


컴파일 타임 의존성, 런타임 의존성의 거리가 멀수록 설계가 유연해지지만 거리가 멀면 멀수록 설계의 복잡도가 상승한다. 대부분의 경우 단순한 설계가 정답이지만 변경에 따르는 고통이 복잡성으로 인한 혼란은 넘어선다면 유연성에 손을 들어주는것이 맞다.



































/

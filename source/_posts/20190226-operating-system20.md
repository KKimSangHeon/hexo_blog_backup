---
title: 20.페이지 테이블, 주소변환/페이징에서의 주소변환
date: 2019-02-26 08:57:15
tags:
categories:
- CS
- Operating System
thumbnail: /images/os.png
---
페이지 테이블, 주소변환

## 주소변환?
컴퓨터에는 CPU, 메모리, 보조기억장치가 존재.
파워를 켜면 메모리 안에 OS가 들어오고 요청하는 대로 프로그램들이 메모리로 들어온다.
프로그램들이 연속으로 들어갈 경우 외부단편화 문제가 발생한다. 그래서 메모리를 프레임 단위로 쪼개서 넣는다. 프로세스들은 흩어져서 프레임 단위로 저장된다. 이것이 가능한것은 CPU와 메모리 사이에 페이지테이블이 존재하기 때문에..
즉 CPU는 페이지 테이블로 인해 CPU는 프로세스가 연속한 상태로 착각한다.
메모리 빈곳(hole)을 다합치면 메모리가 큰데 프로세스를 넣을 수 없는것을 외부단편화라 함

### 메모리 낭비를 위한기술
다이나믹 로딩
링킹
스와핑


### 페이징(메모리 낭비를 줄이기 위한기술)
메모리를 꼭 연속된 공간에 넣을 필요는 없다. 프로그램을 프레임 단위로 잘라서 메모리에 흩어져서 넣는다.
프로세스는 페이지(page)의 집합
메모리는 프레임(frame)의 집합

`페이지를 프레임에 할당`
MMU 내의 재배치 레지스터 값을 바꿈으로서
CPU 는 프로세스가 연속된 메모리 공간에 위치한다고 착각
MMU 는 페이지 테이블 (page table) 이 된다.



`예제`
Page size = 4 bytes
Page Table: 5 6 1 2
<u>논리주소 13 번지는 물리주소 몇 번지?</u>

CPU가 내는 주소는 13이다. 이진수로 나타내면 1101(2) 인데 앞 두숫자 11이 p 이고 01이 d라고 볼 수 있다. (p는 페이지 사이즈 크기만큼 크기를 할당. 페이지 크기가 4이므로 두자리가 된다.) 페이지 테이블의 3번째 인덱스에 저장된 2가 f가 되고 d는 그대로 온다. 즉 10 01이 피지컬 어드레스가 된다. 즉 물리주소는 9번지가 된다. 9번지는 두번째 프레임에서 01만큼 떨어져있다고 할 수 있다.

`예제`
Page Size = 1KB
Page Table: 1 2 5 4 8 3 0 6
<u>논리주소 3000번지는 물리주소 몇 번지?</u>

1kb는 10bit. 3000은 101110111000(2) 이다. 페이지 사이즈는 2^10 이므로 10bit로 표현 가능하다. 즉 d는 뒤의 10자리(1110111000(2)) 이고 p는 앞에 두개(10(2))이다. 즉 2번째 인덱스인 101(2) 그리고 d를 붙인 1110111000 (2) 가 물리주소이다.

<u>물리주소 0x1A53 번지는 논리주소 몇 번지?</u>

1 1010 0101 0011 인데 뒤의 10개가 d 나머지 앞에 110이 프레임 넘버. 6은 페이지 테이블의 7번지에 저장되어 있으므로
111과  10 0101 0011 을 붙인것이 논리주소이다.

### 내부단편화
페이지 사이즈가 4바이트일때 15바이트프로세스를 올리기 위해서는 페이지 4개가 필요하다.
4/4/4/3만큼 할당이 되는데 마지막 페이지의 1바이트가 비게된다. 이는 아무도 쓸수 없으므로 내부단편화 발생.

외부단편화를 페이지로 없앴는데 내부단편화가 발생한다. 내부단편화는 외부단편화에 비해 크기가 미미하므로 큰 문제가 되지 않는다.

페이지 테이블은 CPU안에 넣을 수 있다. 그러면 레지스터로 만들수도있다. 또는 메모리에 넣을 수도 있다.
'CPU에 넣는경우':페이지 테이블을 CPU레지스터로 만드면 주소변환이 정말 빠르다. 단점은 CPU에 넣어야 하므로 많은 데이터를 넣을 수없다.
`메모리 안에 넣을 경우`: 페이지 테이블이 커도 문제가 되지 않는다. 그러나 변환속도가 느리다. 페이지테이블을 읽기위해 메모리를 한번읽고 또 한번 메모리를 읽어야 하므로 2배로 느려진다.

`캐쉬메모리에 페이지 테이블을 넣는경우(실제로 사용됨)`: 페이지 테이블을 넣는 캐쉬메모리를 TLB (Translation Look-aside Buffer) 라 한다. 메모리에 넣는것보다 빠르고 CPU에 넣는것보다 많이 넣을 수 있다. 캐쉬메모리와 유사한 원리로 동작

CPU에서 낸 주소를 읽어오는덱 걸리는 시간을 유효메모리 접근시간이라 한다.
Tm(메모리 읽는속도) = 100ns, Tb(버퍼 읽는속도) = 20ns, hit ratio = 80%
CPU가 낸 주소가 페이지테이블 안에 존재할 경우 hit라고 한다,
유효 메모리 접근시간 : hit확률 *  (Tb+Tm) + hit되지 않을 확률 * (Tb+Tm)

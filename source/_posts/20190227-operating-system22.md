---
title: 22.가상메모리 개요와 원리
date: 2019-02-27 07:48:09
tags:
categories:
- CS
- Operating System
thumbnail: /images/os.png
---


일정크기로 자르는 페이징
논리적 크기로 자르는 세그멘테이션

`보호와 공유적인 측면에서는 페이징보다 세그먼트가 낫다.`

세그먼트는 코드,데이터,스택이라고 잘랐을 때 각 크기는 다르다. 다른 데이터를 남는부분에 넣을라 하면 들어갈 수가 없다. 즉 외부단편화가 발생한다. 치명적인 문제! 외부단편화는 너무 치명적이다.

`그럼 세그멘테이션과 페이징을 합치면 좋지않을까?`
1.처음에는 코드,데이터,스택으로 나누어 세그먼트로 자르고
2.각 세그먼트를 일정한크기(페이지로) 자른다.

이를 Paged segmentation이라 한다.


하지만 이 경우 CPU - 세그먼트 테이블 - 페이지 테이블 - 메모리 를 거치게 되는데 두가지의 테이블을 거치기 때문에 느려진다.


### 가상메모리
물리적인 메모리 크기의 한계를 극복하기 나옴,.
내 컴퓨터의 메모리가 1gb이면 2gb의 프로세스를 올리지는 못한다.

요즘 나오는 컴퓨터는 모두 가상메모리 기법이 적용되어 있다.

`어떤원리로?`: 오류처리, 배열 등 지금은 불필요한것들은 올리지 않고 나중에 필요할 때 올린다. 동적 적재 (dynamic loading)과 비슷한 개념. 즉 각 프로세스를 페이지단위로 자르고 지금필요한것만 올린다. 이를 <u>요구페이징(Demand Paging)</u>이라고 한다.

### Demand Paging
프로세스 이미지는 backing store 에 저장
프로세스는 페이지의 집합
<u>지금 필요한 페이지만 메모리에 올린다(load) - 요구되는 (demand) 페이지만 메모리에 올린다</u>

CPU가 페이지 테이블에 접근했을 때 자기가 읽고자 하는것의 valid 비트가 invalid 일 경우 인터럽트가 걸리게되고 CPU는 하던일을 정지하고 오류처리(필요한것을 들고오는 루틴)를 실행한다.

가상메모리를 만드는 방법은 Demand paging , virtual memory가 있다.

### Page Fault
Demand Paging에서 페이지를 읽으려 했는데 페이지가 없다!
이에따른 Page Falult Routine가 필요하다.


### pure demand paging vs prepaging
`pure demand paging` : 프로그램 실행할 때 아무것도 들고오지 않음. 그러므로 처음시작부터 page fault가 발생하여 처음부터 필요한것을 갖고온다. 즉 이로 인해속도가 느려진다. 하지만 필요한것만 불러오므로 메모리가 절약된다.

`prepaging`: 미리 필요한것을 예측하여 들고온다. 메모리는 낭비될 수 있으나 page fault가 적게일어나므로 속도적인 측면에서 부담이 적다


### swaping vs  demand paging
`swaping` : 화장실 가면 프로세스를 백킹스토어로 몰아내는것. 이때 <u>왔다갔다하는 단위는 프로세스 단위</u>이다,
`demand paging` : 백킹스토어를 <u>왔다갔다 하는 단위가 페이지 단위</u>이다,
